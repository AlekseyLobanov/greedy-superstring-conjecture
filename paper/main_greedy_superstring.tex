\documentclass[11pt]{article}
\usepackage{fullpage}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath, amsfonts, amssymb, amsthm}

\usepackage{setspace}
\usepackage{relsize}
\usepackage{latexsym}
\usepackage{enumitem}

\usepackage{tikz}
\usetikzlibrary{calc,arrows,shapes,backgrounds,patterns,fit,decorations,decorations.pathmorphing}

\usepackage[colorinlistoftodos]{todonotes}
\usepackage[hidelinks]{hyperref}

\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}
\newtheorem{claim}{Claim}
\newtheorem{corollary}{Corollary}
\newtheorem{definition}{Definition}
\newtheorem*{statement}{Statement}
\newtheorem*{remark}{Remark}


\DeclareMathOperator{\overlap}{overlap}
\DeclareMathOperator{\pref}{pref}
\DeclareMathOperator{\suff}{suff}
\DeclareMathOperator{\ein}{in}
\DeclareMathOperator{\eout}{out}
\DeclareMathOperator{\bal}{\Delta}
\DeclareMathOperator{\lvl}{level}
\DeclareMathOperator{\defn}{def}
\DeclareMathOperator{\poly}{poly}
\DeclareMathOperator{\inp}{input}
\DeclareMathOperator{\indegree}{indegree}
\DeclareMathOperator{\outdegree}{outdegree}

\renewcommand{\geq}{\geqslant}
\renewcommand{\leq}{\leqslant}
\newcommand{\sedge}[2]{$({\tt #1}, {\tt #2})$}
\newcommand{\cld}{D_{cl}}
\newcommand{\grd}{D_{gr}}
\newcommand{\cldr}[1]{D_{cl}(#1)}
\newcommand{\grdr}[1]{D_{gr}(#1)}
\newcommand{\clgraph}{G_{cl}}
\newcommand{\grgraph}{G_{gr}}


\tikzstyle{hgedge}=[->,gray!40!white]
\tikzstyle{anypath}=[->,dashed]
\tikzstyle{vertex}=[draw,ellipse,inner sep=0.5mm,minimum size=4mm]
\tikzstyle{inputvertex}=[draw,rectangle,inner sep=1mm,minimum size=5mm]

\newenvironment{mypic}{\begin{center}\begin{tikzpicture}[>=latex,line width=.3mm]}{\end{tikzpicture}\end{center}}


\begin{document}

\sloppy
\begin{titlepage}
%\date{}
\title{Collapsing Superstring Conjecture}
\author{
Alexander Golovnev\thanks{Harvard University. Supported by a Rabin Postdoctoral Fellowship.}
\and
Alexander~S.~Kulikov\thanks{Steklov Institute of Mathematics at St.~Petersburg, Russian Academy of Sciences}
\and
Alexander Logunov\footnotemark[2]
\and
Ivan Mihajlin\thanks{University of California, San Diego}
\and 
Maksim Nikolaev\thanks{St.~Petersburg State University}
}
\maketitle
\thispagestyle{empty}

\begin{abstract}
In the Shortest Common Superstring (SCS) problem, one is given a collection of strings, and needs to find a shortest string containing each of them as a~substring. SCS admits $2\frac{11}{23}$-approximation in polynomial time (Mucha, SODA'13). While this algorithm and its analysis are technically involved, the $30$ years old Greedy Conjecture claims that the trivial and efficient Greedy Algorithm gives a~$2$-approximation for SCS. %The Greedy Algorithm repeatedly merges two strings with the largest intersection into one, until only one string remains.

We develop a graph-theoretic framework for studying approximation algorithms for SCS. The framework is reminiscent of the classical 2-approximation for Traveling Salesman: take two copies of an optimal solution, apply a trivial edge-collapsing procedure, and get an approximate solution. In this framework, we observe two surprising properties of SCS solutions, and we conjecture that they hold for all input instances. 
The first conjecture, that we call Collapsing Superstring conjecture, claims that there is an elementary way to transform any solution repeated twice into the same graph~$G$. This conjecture would give an elementary 2-approximate algorithm for SCS. The second conjecture claims that not only the resulting graph~$G$ is the same for all solutions, but that~$G$ can be computed by an elementary greedy procedure called Greedy Hierarchical Algorithm.

While the second conjecture clearly implies the first one, perhaps surprisingly we prove their equivalence. We support these equivalent conjectures by giving a proof for the special case where all input strings have length at most~$3$ (which until recently had been the only case where the Greedy Conjecture was proven). We also tested our conjectures on millions of instances of SCS.

We prove that the standard Greedy Conjecture implies Greedy Hierarchical Conjecture, while the latter is sufficient for an efficient greedy 2-approximate approximation of SCS. Except for its (conjectured) good approximation ratio, the Greedy Hierarchical Algorithm provably finds a $3.5$-approximation, and finds \emph{exact} solutions for the special cases where we know polynomial time (not greedy) exact algorithms: (1)~when the input strings form a~spectrum of a~string (2)~when all input strings have length at most~$2$.

%In this framework, we give a (stronger) counterpart to the Greedy Conjecture: We conjecture that the presented in this work Greedy Hierarchical Algorithm gives a $2$-approximation for SCS. This algorithm is almost as simple as the standard Greedy Algorithm, and we suggest a~combinatorial approach for proving this conjecture. We support the conjecture by showing that the Greedy Hierarchical Algorithm gives a~$2$-approximation in the case when all input strings have length at most $3$ (which until recently had been the only case where the Greedy Conjecture was proven). We also tested our conjecture on millions of instances of SCS.
%
%Except for its conjectured good approximation ratio, the Greedy Hierarchical Algorithm finds \emph{exact} solutions for the special cases where we know polynomial time (not greedy) exact algorithms: (1)~when the input strings form a spectrum of a~string (2)~when all input strings have length at most $2$.
\end{abstract}
\end{titlepage}

%\tableofcontents

\input intro
\input definitions
\input collapsing
\input greedy_hierarchical
\input relations
\input conclusion
\bibliographystyle{alpha}
\bibliography{main}
\appendix
\input greedy_special_case
%\input collapsing_special_case
\input collapsing_special_case_new
\end{document}
