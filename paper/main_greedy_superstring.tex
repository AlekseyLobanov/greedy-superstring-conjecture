\documentclass[11pt,letterpaper]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,shapes,backgrounds,patterns,fit,decorations,decorations.pathmorphing}
\usepackage{fullpage}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[hidelinks]{hyperref}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{claim}{Claim}

\DeclareMathOperator{\pref}{pref}
\DeclareMathOperator{\suff}{suff}
\DeclareMathOperator{\inter}{inter}

\begin{document}
\sloppy
\author{}
\title{Collapsing Superstring Conjecture}
\maketitle

\section{Introduction}
The {\em shortest common superstring problem} (abbreviated as SCS) is:
given a~set of strings, find a~shortest string that contains all of them as
substrings. The currently record known approximation ratio is 
$2\frac{11}{23}$ due to Mucha~\cite{}.
The corresponding algorithm and its analysis are complicated.
At the same time, an~intriguing {\em greedy conjecture} remains open
for about 40 years already. It states that the following simple 
greedy algorithm is 2-approximate: while there are more than two strings 
in the set, take two of them with the maximum overlap and replace them
with their shortest superstring.

Most of the approaches for approximating SCS are based on an
{\em overlap graph}: it has input strings as nodes, any two nodes 
are joined by an~edge of weight equal to their overlap.  
While it is a~convenient graph structure, it does not seem to be sufficient
for proving the greedy conjecture.

In this paper, we continue the study of the so-called {\em hierarchical graph}
introduced by Golovnev et al.~\cite{}. This graph is designed specifically 
for the SCS problem and contains more useful information about input strings
than just all pairwise overlaps. We present simple and natural greedy algorithm
in the hierarchical graph. 
We demonstrate its usefulness by showing that it finds an optimal solution 
in two well-known polynomially solvable special cases: strings of length~2 and
a~$k$-spectrum of a~string.

We then conjecture that this greedy algorithm is 2-approximate. For this, we introduce an {\em even stronger} conjecture that we call 
{\em Collapsing Superstring Conjecture}. 
Roughly, it says that it is possible to transform a~doubled optimal 
solution into a~greedy solution. 
The corresponding transformation, that we call {\em collapsing}, 
is just replacing two edges $a\alpha \to a\alpha b \to \alpha b$ 
by two edges $a\alpha \to \alpha \to \alpha b$. 
We report on computational experiments that verified the 
conjecture on many datasets (both hand-crafted and generated randomly
according to various distributions). 
We then support the Collapsing Superstring Conjecture by 
proving that it holds for a~special case when the input strings have length~3.

The Collapsing Superstring Conjecture implies immediately that the Greedy
Hierarchical Algorithm is 2-approximate. Surprisingly, it seems to be much
stronger in the following sense. Let $GS$ be the set of edges of a~greedy
solution and let $DOS$ be the set of edges of a~collapsed double optimal
solution. For proving 2-approximability, it suffices to show that $|GS| \le |DOS|$. 
One way of showing this is to prove that $GS \subseteq DOS$. 
The conjecture, at the same time, states that this inclusion holds with equality.

\clearpage
\section{Greedy Hierarchical Algorithm}

\noindent {\sc GreedyHierarchicalAlgorithm}(${\cal S}$):\\
$HG(V,E) \gets \text{hierarchical graph of ${\cal S}$}$\\
$D \gets \{(\operatorname{pref}(s), s), (s, \operatorname{suf}(s) \colon s \in {\cal S})\}$\\
$\textsl{maxlevel} \gets \max\{|s| \colon s \in {\cal S}\}$\\
for \textsl{level} from \textsl{maxlevel} downto 1:\\
\null\quad if $\operatorname{upper-indegree}(v, D) \neq \operatorname{upper-outdegree}(v, D)$:\\
\null\quad\quad balance the total degree of $v$ in $E$ by adding an appropriate number of lower edges \\
\null\quad else:\\
\null\quad\quad ${\cal C} \gets \text{weakly connected component of $v$ in $D$}$\\
\null\quad\quad $u \gets \text{the lexicographically largest string among shortest strings in ${\cal C}$}$\\
\null\quad\quad if ${\cal C}$ is Eulerian, $\varepsilon \not \in {\cal C}$, and $v = u$:\\
\null\quad\quad\quad $D \gets D \cup \{(\pref(v), v), (v, \suff(v))\}$\\
return $D$

\todo[inline]{Sasha, below is the same algo. Which one is better? I suppressed statements like endif (that occupy a~separate line) as I want the pseudocode to be compact enough}


\begin{algorithm}
\caption{Greedy Hierarchical Algorithm}
\hspace*{\algorithmicindent} \textbf{Input:} set of strings~${\cal S}$.\\
\hspace*{\algorithmicindent} \textbf{Output:} a~superstring of~${\cal S}$ as a~path $D$~in the hierarchical graph.
\begin{algorithmic}[1]
\State $HG(V,E) \gets \text{hierarchical graph of ${\cal S}$}$ 
\State $D \gets \{(\operatorname{pref}(s), s), (s, \operatorname{suf}(s) \colon s \in {\cal S})\}$\\
$\textsl{maxlevel} \gets \max\{|s| \colon s \in {\cal S}\}$
\For{\textsl{level} from \textsl{maxlevel} downto 1}
\If{$\operatorname{upper-indegree}(v, D) \neq \operatorname{upper-outdegree}(v, D)$}
\State balance the total degree of $v$ in $E$ by adding an appropriate number of lower edges
\Else
\State ${\cal C} \gets \text{weakly connected component of $v$ in $D$}$
\State $u \gets \text{the lexicographically largest string among shortest strings in ${\cal C}$}$
\If{${\cal C}$ is Eulerian, $\varepsilon \not \in {\cal C}$, and $v = u$}
\State $D \gets D \cup \{(\pref(v), v), (v, \suff(v))\}$
\EndIf
\EndIf
\EndFor
\State return $D$
\end{algorithmic}
\end{algorithm}

\newtheorem*{ghcc}{Greedy Hierarchical Superstring Conjecture}
\begin{ghcc}
The Greedy Hierarchical Algorithm is 2-approximate.
\end{ghcc}

\section{Collapsing Algorithm}
\noindent $\text{\sc Collapse}(HG(V,E), D, v)$:\\
if $(\pref(v), v), (v, \suff(v)) \in D$:\\
\null\quad $D \gets D \setminus \{(\pref(v), v), (v, \suff(v))\}$\\
\null\quad if $|v| > 1$:\\
\null\quad\quad $D \gets D \cup \{(\pref(v), \inter(v)), (\inter(v), \suff(v))\}$

\bigskip

\noindent $\text{\sc CollapsingAlgorithm}(HG(V,E), D)$:\\
for \textsl{level} in $HG$ in descending order:\\
\null\quad for all $v \in V(HG)$ s.t. $|v|=\text{\textsl{level}}$ in lexicographic order:\\
\null\quad\quad if $(\pref(v), v), (v, \suff(v)) \in D$ and collapsing it does not make~$D$ disconnected:\\
\null\quad\quad\quad $\text{\sc Collapse}(HG(V,E), D, v)$

\section{Further Directions and Open Problems}
The natural open problem is to prove the Collapsing Superstring Conjecture.
It would also be interesting to find other applications of the 
hierarchical graphs. We list two such potential applications below.
\begin{description}
\item[Genome assembly.] As we illustrated, the hierarchical graph in a~sense
generalizes de Bruijn graph. The latter one is used heavily 
in genome assembly~\cite{}.
Can one adopt the hierarchical graph for this task? For this, one
would need to come up with a~compact representation of the graph
(as datasets in genome assembly are massive) as well as with a~way of
handling errors in the input data.

\item[Exact algorithms.] Can one use hierarchical graphs to solve SCS exactly in time $(2-\varepsilon)^n$?
\end{description}

\section{Unsorted}

\tikzstyle{anypath}=[->,dashed]
\tikzstyle{vertex}=[draw,ellipse,inner sep=0.5mm]
\tikzstyle{inputvertex}=[draw,rectangle,inner sep=1mm]

\begin{center}
\begin{tikzpicture}[xscale=1.3] 
  \begin{scope}
    \foreach \x/\y/\n in {4/5/abba, 4/4/bab, 2/4/dbb, 7/4/cab, 9/4/aac, 8/5/abca}
      \node[inputvertex] (\n) at (\x,\y) {\tt \n};
%      
    \foreach \x/\y/\n in {3/4/bba, 5/4/abb, 6/4/abc, 8/4/bca, 2/3/db, 3/3/bb, 4/3/ba, 5/3/ab, 6/3/bc, 7/3/ca, 8/3/aa, 9/3/ac, 3/2/d, 5/2/b, 6/2/a, 7/2/c}
      \node[vertex] (\n) at (\x,\y) {\tt \n};
%      
    \node[vertex] (e) at (6,1) {$\varepsilon$};
    
    \foreach \y in {0,...,4}
      \node[draw=none] at (0,\y+1) {\y};
    
    
    \foreach \s/\f/\t in {db/dbb/bb, ba/bab/ab, abb/abba/bba, ca/cab/ab, abc/abca/bca, aa/aac/ac, bc/bca/ca, ab/abc/bc, b/bc/c} {
      \path (\s) edge[->] (\f);
      \path (\f) edge[->] (\t);
    }

    \foreach \s/\t in {d/db, b/ba, bba/ba, ba/a, ab/b, a/ab, ab/abb, c/ca, bb/b, bb/bba, abb/bb}
      \path (\s) edge[->] (\t);

    \path (b) edge[bend left=15,->] (bb); 
    \path (db) edge[bend right=15,->] (b); 
    
    \path (a) edge[bend right=10,->] (aa); 
    \path (aa) edge[bend right=10,->] (a); 
    
    \path (a) edge[->,bend right=8] (ac);
    \path (ca) edge[->,bend right=15] (a);
    
    \path (ac) edge[->,out=-90,in=0] (c);
      
    \foreach \s in {a,b,c,d} {
      \path (\s) edge[->,bend left=10] (e);
      \path (e) edge[->,bend left=10] (\s);
    }
  \end{scope}
\end{tikzpicture}
\end{center}

\end{document}