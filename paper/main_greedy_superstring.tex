\documentclass[11pt,letterpaper]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,shapes,backgrounds,patterns,fit,decorations,decorations.pathmorphing}
\usepackage{fullpage}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[hidelinks]{hyperref}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{claim}{Claim}
\newtheorem{definition}{Definition}

\DeclareMathOperator{\overlap}{overlap}
\DeclareMathOperator{\pref}{pref}
\DeclareMathOperator{\suff}{suff}
\DeclareMathOperator{\inter}{inter}

\tikzstyle{hgedge}=[->,gray]
\tikzstyle{anypath}=[->,dashed]
\tikzstyle{vertex}=[draw,ellipse,inner sep=0.25mm]
\tikzstyle{inputvertex}=[draw,rectangle,inner sep=1mm]

\begin{document}
\sloppy
\author{}
\date{}
\title{Collapsing Superstring Conjecture}
\maketitle
\tableofcontents

\section{Introduction}
The {\em shortest common superstring problem} (abbreviated as SCS) is:
given a~set of strings, find a~shortest string that contains all of them as
substrings. The currently record known approximation ratio is 
$2\frac{11}{23}$ due to Mucha~\cite{}.
The corresponding algorithm and its analysis are complicated.
At the same time, an~intriguing {\em greedy conjecture} remains open
for about 40 years already. It states that the following simple 
greedy algorithm is 2-approximate: while there are more than two strings 
in the set, take two of them with the maximum overlap and replace them
with their shortest superstring.

Most of the approaches for approximating SCS are based on an
{\em overlap graph}: it has input strings as nodes, any two nodes 
are joined by an~edge of weight equal to their overlap.  
While it is a~convenient graph structure, it does not seem to be sufficient
for proving the greedy conjecture.

In this paper, we continue the study of the so-called {\em hierarchical graph}
introduced by Golovnev et al.~\cite{}. This graph is designed specifically 
for the SCS problem and contains more useful information about input strings
than just all pairwise overlaps. We present simple and natural greedy algorithm
in the hierarchical graph. 
We demonstrate its usefulness by showing that it finds an optimal solution 
in two well-known polynomially solvable special cases: strings of length~2 and
a~$k$-spectrum of a~string.

We then conjecture that this greedy algorithm is 2-approximate. For this, we introduce an {\em even stronger} conjecture that we call 
{\em Collapsing Superstring Conjecture}. 
Roughly, it says that it is possible to transform a~doubled optimal 
solution into a~greedy solution. 
The corresponding transformation, that we call {\em collapsing}, 
is just replacing two edges $a\alpha \to a\alpha b \to \alpha b$ 
by two edges $a\alpha \to \alpha \to \alpha b$. 
We report on computational experiments that verified the 
conjecture on many datasets (both hand-crafted and generated randomly
according to various distributions). 
We then support the Collapsing Superstring Conjecture by 
proving that it holds for a~special case when the input strings have length~3.

The Collapsing Superstring Conjecture implies immediately that the Greedy
Hierarchical Algorithm is 2-approximate. Surprisingly, it seems to be much
stronger in the following sense. Let $GS$ be the set of edges of a~greedy
solution and let $DOS$ be the set of edges of a~collapsed double optimal
solution. For proving 2-approximability, it suffices to show that $|GS| \le |DOS|$. 
One way of showing this is to prove that $GS \subseteq DOS$. 
The conjecture, at the same time, states that this inclusion holds with equality.

\section{Definitions}
%By $u\sqsupset v$ ($u\sqsubset v$) we denote that $u$ is a suffix (prefix) of $v$.
For strings~$s$ and~$t$, by $\overlap(s,t)$
we denote the longest suffix of~$s$ that is also 
a~prefix of~$t$. By $\pref(s,t)$
we denote the first $|s|-|\overlap(s,t)|$ symbols of $s$.
Similarly, $\suff(s,t)$ is the last
$|t|-|\overlap(s,t)|$ symbols of~$t$. 
By $\pref(s)$ and $\suff(s)$ we denote, respectively,
the first and the last $|s|-1$ symbols of~$s$.
The empty string is denoted by $\varepsilon$.

Throughout the paper by ${\cal S}=\{s_1, \dots, s_n\}$ we denote
a~set of~$n$ input strings. We assume that no input string is a~substring of another (such a~substring can be removed from $\mathcal{S}$ on the preprocessing stage). Note that SCS is a~{\em permutation problem}: to find a~shortest string containing all $s_i$'s in a given order one just
overlaps the strings in this order. This simple observation makes many connections to other permutation problems, including different versions of the traveling salesman problem.

\begin{definition}[hierarchical graph]
  A \emph{hierarchical graph} $HG_{\cal S}=(V,A)$ of ${\cal S}$ is a~weighted directed graph defined as follows:
  \begin{itemize}
  \item The set of nodes~$V$ consists of all prefixes and suffixes (including the empty string $\varepsilon$) of the strings from~${\cal S}$.
  \item For two such strings $u,v \in V$, $(u,v) \in A$ when either 
\begin{itemize}
	\item $u$ is a prefix of $v$ of length $|v|-1$ (i.e., $u=\pref(v)$); in this case the weight $w(u,v)=1$ and $(u,v)$ is called an \emph{up-arc}, or
	\item $v$ is a suffix of $u$ of length $|u|-1$ (i.e., $v=\suff(u)$); in this case the weight $w(u,v)=0$ and $(u,v)$ is called a \emph{down-arc}.
\end{itemize}
  \end{itemize}
\end{definition}

Figure~\ref{fig:hgexfirst} gives an example of the hierarchical graph as well as shows that the terminology of up- and down-arcs comes from placing all the strings of the same length at the same layer where the $i$-th layer contains strings of length~$i$. 


\newcommand{\verta}{
    \foreach \x/\y/\n in {4/5/abba, 4/4/bab, 2/4/dbb, 7/4/cab, 9/4/aac, 8/5/abca}
      \node[inputvertex] (\n) at (\x,\y) {\tt \n};
%      
    \foreach \x/\y/\n in {3/4/bba, 5/4/abb, 6/4/abc, 8/4/bca, 2/3/db, 3/3/bb, 4/3/ba, 6/3/ab, 7/3/ca, 8/3/aa, 9/3/ac, 3/2/d, 5/2/b, 6/2/a, 7/2/c}
      \node[vertex] (\n) at (\x,\y) {\tt \n};
%      
    \node[vertex] (e) at (6,1) {$\varepsilon$};
}

\begin{figure}[ht]
\begin{center}

\begin{tikzpicture}
  \begin{scope}
    {\verta}
    
    \foreach \y in {0,...,4}
      \node[draw=none] at (0,\y+1) {\y};
    
    
    \foreach \s/\f/\t in {db/dbb/bb, ba/bab/ab, abb/abba/bba, ca/cab/ab, abc/abca/bca, aa/aac/ac} {
      \path (\s) edge[hgedge] (\f);
      \path (\f) edge[hgedge] (\t);
    }

    \foreach \s/\t in {d/db, b/ba, bba/ba, ba/a, ab/b, a/ab, ab/abb, ab/abc, c/ca, bca/ca, bb/b, bb/bba, abb/bb}
      \path (\s) edge[hgedge] (\t);

    \path (b) edge[bend left=15,hgedge] (bb); 
    \path (db) edge[bend right=15,hgedge] (b); 
    
    \path (a) edge[bend right=10,hgedge] (aa); 
    \path (aa) edge[bend right=10,hgedge] (a); 
    
    \path (a) edge[hgedge,bend right=8] (ac);
    \path (ca) edge[hgedge,bend right=15] (a);
    
    \path (ac) edge[hgedge,out=-90,in=0] (c);
      
    \foreach \s in {a,b,c,d} {
      \path (\s) edge[hgedge,bend left=10] (e);
      \path (e) edge[hgedge,bend left=10] (\s);
    }
  \end{scope}
\end{tikzpicture}
\end{center}
\caption{The hierarchical graph for  
$\mathcal{S}=\{{\tt abba}, {\tt abca}, {\tt dbb}, {\tt bab}, {\tt cab}, {\tt aac}\}$. The strings from $\mathcal{S}$ are given in rectangles.}\label{fig:hgexfirst}
\end{figure}

What we are looking for in this graph is a shortest
walk from $\varepsilon$ to $\varepsilon$ going through all the vertices from~$\mathcal{S}$.
It is not difficult to see that the length of a walk from $\varepsilon$ to $\varepsilon$ equals the length of the string spelled by this walk. This is just because each arc going up
has weight $1$ and adds one symbol to the current string. 
For example, in the graph of Fig.~\ref{fig:hgexfirst} a walk $\varepsilon\to{\tt b}\to{\tt ba}\to{\tt bab}\to{\tt ab}\to{\tt abc}\to{\tt abca}\to{\tt bca}\to{\tt ca}\to{\tt a}\to\varepsilon$ has length $5$ and spells a string {\tt babca} of length $5$ in a natural way.




\section{Greedy Hierarchical Algorithm}
In this section, we present a~simple and natural
greedy algorithm for finding a~superstring in
polynomial time. It constructs an Eulerian multiset of
edges~$D$ in $HG_{\cal S}$ going through 
$\varepsilon$ and all nodes from ${\cal S}$.
 Such a~multiset~$D$ always spells a~superstring of ${\cal S}$. 
This set is constructed in a~stingy fashion. 
Namely, the algorithm only add edges to~$D$ if it is absolutely necessary: either to balance the degree of a~node or to ensure connectivity (as $D$ must be Eulerian). More precisely, it starts from considering the input strings~${\cal S}$. Since we assume that no $s \in {\cal S}$ is a~substring of another $t \in {\cal S}$, there is no down-path from~$t$ to~$s$ in $HG_{\cal S}$. This means that any walk through $\varepsilon$ and ${\cal S}$ goes through edges $\{(\operatorname{pref}(s), s), (s, \operatorname{suf}(s)) \colon s \in {\cal S}\}$. The algorithm adds all of them to~$D$ and starts processing all the nodes level by level. On each level, we process the nodes in the lexicographic order. If the degree of the current node~$v$ is imbalanced, we balance it by adding an appropriate number of incoming (i.e., $(\pref(v),v)$) or outgoing (i.e., $(v, \suff(v))$) edges from the previous level. In case $v$ is balanced, we just skip it. The only exception when we do not skip it is when {\em $v$~lies in an Eulerian component and $v$ is the last chance of this component to be connected to the rest of the edges in~$D$}. We give an~example of such a~situation below. The pseudocode is given in~Algorithm~\ref{algo:gha}.


\begin{algorithm}
\label{algo:gha}
\caption{Greedy Hierarchical Algorithm (GHA)}
\hspace*{\algorithmicindent} \textbf{Input:} set of strings~${\cal S}$.\\
\hspace*{\algorithmicindent} \textbf{Output:} a~superstring of~${\cal S}$ as a~path $D$~in the hierarchical graph.
\begin{algorithmic}[1]
\State $HG(V,E) \gets \text{hierarchical graph of ${\cal S}$}$ 
\State $D \gets \{(\operatorname{pref}(s), s), (s, \operatorname{suf}(s)) \colon s \in {\cal S}\}$\\
$\textsl{maxlevel} \gets \max\{|s| \colon s \in {\cal S}\}$
\For{\textsl{level} from \textsl{maxlevel} downto 1}
\If{$\operatorname{upper-indegree}(v, D) \neq \operatorname{upper-outdegree}(v, D)$}
\State balance the total degree of $v$ in $E$ by adding an appropriate number of lower edges
\Else
\State ${\cal C} \gets \text{weakly connected component of $v$ in $D$}$
\State $u \gets \text{the lexicographically largest string among shortest strings in ${\cal C}$}$
\If{${\cal C}$ is Eulerian, $\varepsilon \not \in {\cal C}$, and $v = u$}
\State $D \gets D \cup \{(\pref(v), v), (v, \suff(v))\}$
\EndIf
\EndIf
\EndFor
\State return $D$
\end{algorithmic}
\end{algorithm}

\todo[inline]{Sasha G, think about a good example highlighting all properties of this algorithm}

The advantage of GHA over GA is that GHA is more flexible in the following sense. On every step, GA selects two strings and fixes tightly an order on them. GHA instead works to ensure connectivity. When the resulting set~$D$ is connected, an actual order of input strings will be given by the corresponding Eulerian cycle through~$D$.


We are now ready to state the main conjecture of this paper.
\newtheorem*{ghcc}{Greedy Hierarchical Superstring Conjecture}
\begin{ghcc}
GHA is 2-approximate.
\end{ghcc}
In the rest of this section, we show the behavior of GHA on various datasets. In particular, we prove that GHA solves optimally two well-known polynomialy solvable special cases of SCS. In the next section, we suggest a~way of proving the conjecture by connecting GHA to another simple and natural algorithm.

\subsection{Strings of Length~2}
\todo[inline]{Sasha, please write}

\subsection{Spectrum of a~String}
By a~$k$-spectrum of a~string $s$ 
(of length at least~$k$)
we call a~set of all substrings of~$s$ of length~$k$.

\begin{lemma}
Let ${\cal S}$ be a~$k$-spectrum of an unknown string~$s$. Then $GHA({\cal S})$ returns a~superstring of length at most~$|s|$. 
\end{lemma}
\todo[inline]{Sasha, please write this subsection}

\subsection{Tough Dataset}
There is a~well-known dataset consisting of just three strings where the classical greedy algorithm produces a~superstring that is almost twice longer than an optimal one: $s_1=cc(ab)^n$, $s_2=(ba)^{n+1}$, $s_3=(ab)^ndd$. Since $\overlap(s_1, s_3)=2n$,
 while $\overlap(s_1,s_2)=\overlap(s_2,s_3)=2n-1$, the greedy algorithm produces a~permutation $(s_1, s_3, s_2)$ (or $(s_2,s_1,s_3)$). I.e., by greedily taking the massive overlap of length $2n$ it loses the possibility to insert $s_2$ between $s_1$ and $s_3$. The resulting superstring has length $4n+6$. At the same time, the optimal superstring corresponds to a~permutation $(s_1,s_2,s_3)$ and has length $2n+8$.
 
 The algorithm GHA makes a~similar mistake on this dataset. We illustrate this for the case $n=3$.
 \todo[inline]{Sasha, give an example} 



\section{Collapsing Algorithm}
\begin{algorithm}
\caption{Collapse}
\hspace*{\algorithmicindent} \textbf{Input:} hierarchical graph $HG(V,E)$, multiset of edges $D \subseteq E$, node $v \in V$.
%\hspace*{\algorithmicindent} \textbf{Output:} a~superstring of~${\cal S}$ as a~path $D$~in the hierarchical graph.
\begin{algorithmic}[1]
\If{$(\pref(v), v), (v, \suff(v)) \in D$:}
\State $D \gets D \setminus \{(\pref(v), v), (v, \suff(v))\}$
\If{$|v| > 1$:}
\State $D \gets D \cup \{(\pref(v), \pref(\suff(v))), (\pref(\suff(v)), \suff(v))\}$
\EndIf
\EndIf
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Collapsing Algorithm (CA)}
\hspace*{\algorithmicindent} \textbf{Input:} hierarchical graph $HG(V,E)$, multiset of edges $D \subseteq E$.\\
\hspace*{\algorithmicindent} \textbf{Output:} TBW.
% a~superstring of~${\cal S}$ as a~path $D$~in the hierarchical graph.
\begin{algorithmic}[1]
\For{\textsl{level} in $HG$ in descending order:}
\For{all $v \in V(HG)$ s.t. $|v|=\text{\textsl{level}}$ in lexicographic order:}
\While{$(\pref(v), v), (v, \suff(v)) \in D$ and collapsing it does not make~$D$ disconnected:}
\State $\text{\sc Collapse}(HG(V,E), D, v)$
\EndWhile
\EndFor
\EndFor
\State return $D$
\end{algorithmic}
\end{algorithm}


\section{Further Directions and Open Problems}
The natural open problem is to prove the Collapsing Superstring Conjecture.
It would also be interesting to find other applications of the 
hierarchical graphs. We list two such potential applications below.
\begin{description}
\item[Genome assembly.] As we illustrated, the hierarchical graph in a~sense
generalizes de Bruijn graph. The latter one is used heavily 
in genome assembly~\cite{}.
Can one adopt the hierarchical graph for this task? For this, one
would need to come up with a~compact representation of the graph
(as datasets in genome assembly are massive) as well as with a~way of
handling errors in the input data.

\item[Exact algorithms.] Can one use hierarchical graphs to solve SCS exactly in time $(2-\varepsilon)^n$?
\end{description}


\end{document}